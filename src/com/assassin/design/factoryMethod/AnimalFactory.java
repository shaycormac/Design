package com.assassin.design.factoryMethod;

/**
 * @Author: Shay-Patrick-Cormac
 * @Email: fang47881@126.com
 * @Ltd: 金螳螂企业（集团）有限公司
 * @Date: 2018/1/16 14:08
 * @Version: 1.0
 * @Description: 工厂方法，是抽象工厂的一种简单模式？？？？？
 * 定义一个可以生产动物的抽象工厂，工厂是抽象的，动物也是抽象的，需要对应的工厂去实现
 * <p>
 * 定义一个创建产品对象的工厂接口，让子类决定实例化哪一个类，将实际创建工作推迟到子类当中。它的核心结构有四个角色，分别是
 * <p>
 * 【抽象工厂】Factory ： 具体工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。
 * 【具体工厂】ConcreteFactory ： 实现了抽象工厂接口的具体类。具体工厂角色含有与业务密切相关的逻辑。
 * 【抽象产品】Product ： 定义具体产品类所需要实现的逻辑和功能方法。
 * 【具体产品】 ConcreteProduct ： 实现具体逻辑和功能的类。
 * <p>
 * 工厂方法模式仿佛已经很完美的对对象的创建进行了包装，使得客户程序中仅仅处理抽象产品角色提供的接口。那我们是否一定要在代码中遍布工厂呢？大可不必。也许在下面情况下你可以考虑使用工厂方法模式：
 * 当客户程序不需要知道要使用对象的创建过程。
 * 客户程序使用的对象存在变动的可能，或者根本就不知道使用哪一个具体的对象。
 */

interface AnimalFactory {
    Animal createAnimal();
}
